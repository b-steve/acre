#' Calculate location density
#' 
#' Calculates the estimated density of a location, given its observed capture 
#' history and auxiliary information.
#'
#' @param fit an object generated from the model fitting function 
#'    [fit.acre] or the bootstrap process [boot.acre].
#' @param call_id an numeric vector indicating which call ID's to calculate
#'    density for.
#' @param animal_id an numeric value indicating animal ID. Should only be 
#'    specified if `fit` is an `animalID` model.
#' @param session an integer value indicating the session of detector array and 
#'    individual(s) to be plotted. 
#' @param mask a list or a data frame. Generated by [create.mask()].
#' @param warn_toa a logical value indicates whether to issue warning in the 
#'    case of `toa` data with only a single call.
#' @param newdata data.frame; contains any covariates that will be used 
#'    for all extended parameters.
#'
#' @return 
#' @export 
#'
#' @examples
location_density <- function(fit, call_id, animal_id=NULL, session=1, 
                             mask=get_mask(fit)[[session]], warn_toa=F, 
                             newdata=NULL) {
  # Note input validation for call_id, animal_id, session
  # is handled in `get_capt_by_id()`
  
  density_types <- c(fit$infotypes, "capt", "Dsurface")
   
  if ("ss" %in% density_types) {
    # stop("Combined density plotting is not currently implemented for signal
    #      strength models.")
    density_types <- density_types[which(density_types != "capt")]
  }
  
  # Note each density function returns a df with columns:
  #   ID, x, y, [density_name]_density
  density_list <- lapply(density_types, function(d_type) {
    switch(
      d_type,
      "Dsurface" = Dsurface_density(fit, session, mask),
      "capt" = capt_density(fit, call_id, animal_id, session, mask),
      "toa"  = toa_density(fit, call_id, animal_id, session, mask,
                           warn=warn_toa),
      "dist" = dist_density(fit, call_id, animal_id, session, mask),
      "ss"   = ss_density(fit, call_id, animal_id, session, mask),
      "bearing" = bearing_density(fit, call_id, animal_id, session, mask),
      stop(paste0("Unknown density type: '", d_type, 
                  "', currently supported types are: 'capt', 'ss', 'dist',
                   'bearing', 'toa', 'Dsurface'."))
    )
  })
  
  # For clarity
  names(density_list) <- density_types
  
  # Keep the three key columns only once
  base_cols <- density_list[[1]][, c("ID", "x", "y")]
  
  # Pull the single density column from each data frame
  dens_mat <- do.call(
    cbind,
    lapply(density_list, `[`, "z")
  )
  
  # Rename those columns to match the density types
  colnames(dens_mat) <- paste0(density_types, "_density")
  
  # Final data frame
  merged_densities <- cbind(base_cols, dens_mat)
  
  # Create the combined density column by multiplying all density columns 
  merged_densities$combined_density <- Reduce(`*`, merged_densities[-c(1:3)])
  
  # Return the final data frame
  return(merged_densities)
}

#' Calculate density breaks for given probabilities
#' 
#' Calculates appropriate breaks for given density from provided probability 
#' bins.
#'
#' @param dens a numeric vector of densities.
#' @param probability_breaks the probabilities at which to calculate density 
#'    breaks.
#'
#' @return
#'
#' @examples
get_density_breaks_from_probability <- function(dens, probability_breaks) {
  dens.sort <- sort(dens, decreasing = TRUE)
  probs.sort <- cumsum(dens.sort)/sum(dens.sort)
  prob.levels <- probability_breaks
  levels <- numeric(length(prob.levels))
  for (i in 1:length(prob.levels)){
    levels[i] <- dens.sort[which(abs(probs.sort - prob.levels[i]) ==
                                   min(abs(probs.sort - prob.levels[i])))[1]]
  }
  
  return(levels)
}


#' Calculate the distance density
#' 
#' Calculates the distance density of calls from a model fit using 
#' [fit.acre].
#'
#' @inheritParams location_density
#'
#' @return a data frame with columns `x`, `y` and `z`
#' @export
#'
#' @examples
dist_density <- function(fit, call_id, animal_id=NULL, session=1, 
                         mask=get_mask(fit)[[session]]) {
  # `get_capt_by_id()` validates `call_id`, `animal_id`, `session`
  
  if (!("dist" %in% fit$infotypes)) {
    stop(paste0("'fit' does not contain 'dist' information. ",
                "Infotypes available for the fit provided are: ", 
                paste0(fit$infotypes, collapse=", "), ", Dsurface, capt"))
  }
  
  # Check whether the model extends any parameters
  par_extended <- !is.null(get_par_extend(fit))
  
  # Grab appropriate capture data & detection params
  det_pars <- as.list(coef(fit, type="fitted"))
  capt <- get_capt_by_id(fit, call_id, animal_id, session)
  bincapt <- get_capt_by_id(fit, call_id, animal_id, session, return_bincapt=T)
  traps <- get_trap(fit)[[session]]
  
  # Calculate mask - trap distances
  dists <- distances(traps, as.matrix(mask))
  # If trap is exactly on a mask point, distance will be 0 => numerical issues
  dists[dists == 0] <- .Machine$double.eps
  
  # Deal with extended parameters
  if (par_extended) {
    # Calculates the parameter values for each mask_point - trap combination
    ext_par_matrices <- get_par_extend_matrix(fit, mask, traps)
    det_pars[names(ext_par_matrices)] <- ext_par_matrices
  }
  
  # Grab our estimated alpha/s and beta/s
  alpha <- det_pars[["alpha"]]
  betas <- alpha/dists
  
  # A list to store each call density
  density_list <- vector("list", length(call_id))
  
  for (i in seq_along(call_id)) {
    cid <- call_id[i]
    
    # Grab the capt & bincapt for this call ID
    sub_capt <- subset(capt, ID == cid)
    # Make sure to remove ID column when doing calculations
    sub_bin  <- subset(bincapt, ID == cid)[,-1] 
    dist_capt <- sub_capt$dist
    
    traps_used <- which(sub_bin == 1)
    
    # Keep only detectors with a non-missing recorded distances
    traps_used <- traps_used[!is.na(dist_capt)]
    
    # If there is at least 1 non-NA detection
    if (length(traps_used) > 0) {
      
      # If alpha has been extended
      if (par_extended && is.matrix(alpha)) {
        dens_mat <- dgamma(dist_capt[!is.na(dist_capt)],
                           shape = alpha[traps_used, ],
                           rate = betas[traps_used, ])
      } else {
        dens_mat <- dgamma(dist_capt[!is.na(dist_capt)],
                           shape = alpha,
                           rate = betas[traps_used, ])
      }
      # Take product if multiple traps triggered
      if (length(traps_used) > 1) {
        z <- matrixStats::colProds(dens_mat)
      } else {
        z <- dens_mat
      }
    } else {
      # Case of no detections
      z <- rep(1, nrow(mask))
    }
    
    density_list[[i]] <- data.frame(
      ID = cid, x = mask[, 1], y = mask[, 2], z = z
    )
  }
  
  return(do.call(rbind, density_list))
}


#' Calculate the bearing density
#' 
#' Calculates the bearing density of calls from a model fit using 
#' [fit.acre].
#'
#' @inheritParams location_density
#'
#' @return a data frame with columns `x`, `y` and `z`
#' @export
#'
#' @examples
bearing_density <- function(fit, call_id, animal_id=NULL, session=1, 
                            mask=get_mask(fit)[[session]]) {
  # `get_capt_by_id()` validates `call_id`, `animal_id`, `session`
  
  if (!("bearing" %in% fit$infotypes)) {
    stop(paste0("'fit' does not contain 'bearing' information. ",
                "Infotypes available for the fit provided are: ", 
                paste0(fit$infotypes, collapse=", "), ", Dsurface, capt"))
  }
  
  # Check whether the model extends any parameters
  par_extended <- !is.null(get_par_extend(fit))
  
  # Grab appropriate capture data & detection params
  det_pars <- as.list(coef(fit, type="fitted"))
  capt <- get_capt_by_id(fit, call_id, animal_id, session)
  bincapt <- get_capt_by_id(fit, call_id, animal_id, session, return_bincapt=T)
  traps <- get_trap(fit)[[session]]
  
  # Deal with extended parameters
  if (par_extended) {
    # Calculates the parameter values for each mask_point - trap combination
    ext_par_matrices <- get_par_extend_matrix(fit, mask, traps)
    det_pars[names(ext_par_matrices)] <- ext_par_matrices
  }
  
  # Grab our estimated kappa parameter
  kappa <- det_pars[["kappa"]]
  
  # A list to store each call density
  density_list <- vector("list", length(call_id))
  
  # Calculate bearings for each trap
  mask_bearings <- bearings(traps, as.matrix(mask))
  
  for (i in seq_along(call_id)) {
    cid <- call_id[i]
    
    # Grab the capt & bincapt for this call ID
    sub_capt <- subset(capt, ID == cid)
    # Make sure to remove ID column when doing calculations
    sub_bin  <- subset(bincapt, ID == cid)[,-1] 
    traps_used <- which(sub_bin == 1)
    bearing_capt <- sub_capt$bearing
    
    # Keep only detectors with a non-missing recorded bearings
    traps_used <- traps_used[!is.na(bearing_capt)]
    bearing_capt <- bearing_capt[!is.na(bearing_capt)]
    
    # Only care about the bearings relative to active traps
    active_bearings <- mask_bearings[traps_used, ]
    
    # If there is at least 1 non-NA detection
    if (length(traps_used) > 0) {
      # If alpha has been extended
      if (par_extended && is.matrix(kappa)) {
        dens_mat <- CircStats::dvm(bearing_capt, 
                                   mu = active_bearings, 
                                   kappa = kappa[traps_used, ])
      } else {
        dens_mat <- CircStats::dvm(bearing_capt, 
                                   mu = active_bearings, 
                                   kappa = kappa)
      }
      # Take product if multiple traps triggered
      if (length(traps_used) > 1) {
        z <- matrixStats::colProds(dens_mat)
      } else {
        z <- dens_mat
      }
      
    } else {
      # All triggered traps had NA bearings => no usable distance info
      z <- rep(1, nrow(mask))
    }
    
    
    density_list[[i]] <- data.frame(
      ID = cid, x = mask[, 1], y = mask[, 2], z = z
    )
  }
  
  return(do.call(rbind, density_list))
}

#' Calculate the time of arrival density
#' 
#' Calculates the time of arrival density of calls from a model fit using 
#' [fit.acre].
#' 
#' @inheritParams location_density
#'
#' @return a data frame with columns `x`, `y` and `z`
#' @export
#'
#' @examples
toa_density <- function(fit, call_id, animal_id=NULL, session=1, 
                        mask=get_mask(fit)[[session]], warn=T) {
  # `get_capt_by_id()` validates `call_id`, `animal_id`, `session`

  if (!("toa" %in% fit$infotypes)) {
    stop(paste0("'fit' does not contain 'toa' information. ",
                "Infotypes available for the fit provided are: ", 
                paste0(fit$infotypes, collapse=", "), ", Dsurface, capt"))
  }
  
  # Check whether the model extends any parameters
  par_extended <- !is.null(get_par_extend(fit))
  
  # Grab appropriate capture data & detection params
  det_pars <- as.list(coef(fit, type="fitted"))
  capt <- get_capt_by_id(fit, call_id, animal_id, session)
  bincapt <- get_capt_by_id(fit, call_id, animal_id, session, return_bincapt=T)
  traps <- get_trap(fit)[[session]]
  
  # Calculate mask - trap distances
  dists <- distances(traps, as.matrix(mask))
  # If trap is exactly on a mask point, distance will be 0 => numerical issues
  dists[dists == 0] <- .Machine$double.eps
  
  # Deal with extended parameters
  if (par_extended) {
    # Calculates the parameter values for each mask_point - trap combination
    ext_par_matrices <- get_par_extend_matrix(fit, mask, traps)
    det_pars[names(ext_par_matrices)] <- ext_par_matrices
  }
  
  # Grab our estimated sigma_toa parameter
  sigma_toa <- det_pars[["sigma.toa"]]
  
  # A list to store each call density
  density_list <- vector("list", length(call_id))
  
  single_trap_detection = F
  for (i in seq_along(call_id)) {
    cid <- call_id[i]
    
    # Grab the capt & bincapt for this call ID
    sub_capt <- subset(capt, ID == cid)
    # Make sure to remove ID column when doing calculations
    sub_bin  <- subset(bincapt, ID == cid)[,-1] 
    traps_used <- which(sub_bin == 1)
    toa_capt <- sub_capt$toa
    
    # Keep only detectors with a non-missing recorded toa's
    ok <- !is.na(toa_capt)
    traps_used <- traps_used[ok]
    toa_capt <- toa_capt[ok]
    
    # Need at least 2 detections to be able to use arrival time data
    if (length(traps_used) < 2) {
      single_trap_detection = T
      mask.dens <- 1
    } else {
      dists.mask <- dists[traps_used, ]
      prod.times <- toa_capt - dists.mask/fit$args$sound.speed
      toa.ssq <- apply(prod.times, 2, function(x) sum((x - mean(x))^2))
      
      if (par_extended && is.matrix(sigma_toa)) {
        sig2 <- sigma_toa[traps_used, ]^2
        # Recycle the ssq vector, need to do this otherwise normal recycling 
        # doesn't do what we want
        toa.ssq <- matrix(rep(toa.ssq, times = nrow(sig2)), nr=nrow(sig2), byrow=T)
        mask.dens <- (2*pi*sig2)^((1 - sum(sub_bin))/2)*exp(toa.ssq/(-2*sig2))
        # mask.dens <- matrixStats::colProds(mask.dens)
        mask.dens <- colSums(mask.dens)
      } else {
        mask.dens <- (2*pi*sigma_toa^2)^((1 - sum(sub_bin))/2)*
          exp(toa.ssq/(-2*sigma_toa^2))
      }
    }
    
    density_list[[i]] <- data.frame(
      ID = cid, x = mask[, 1], y = mask[, 2], z = mask.dens
    )
  }
  
  if (warn & single_trap_detection) {
    warning(paste("Some calls were detected by only a single trap. 
    The use of toa data requires a call to be detected by at least 
    2 traps. Toa density for corresponding calls has been set to 1 
                  across the entire mask for such cases."))
  }
  return(do.call(rbind, density_list))
}

#' Calculate the signal strength density
#' 
#' Calculates the signal strength density of calls from a model fit using 
#' [fit.acre].
#'
#' @inheritParams location_density
#'
#' @return a data frame with columns `x`, `y` and `ss_dens`
#' @export
#'
#' @examples
ss_density <- function(fit, call_id, animal_id=NULL, session=1, 
                       mask=get_mask(fit)[[session]], newdata=NULL) {
  # Note input validation for call_id, animal_id, session
  # is handled in `get_capt_by_id()`
  
  if (!("ss" %in% fit$infotypes)) {
    stop(paste0("'fit' does not contain 'ss' information. ",
                "Infotypes available for the fit provided are: ", 
                paste0(fit$infotypes, collapse=", "), ", Dsurface, capt"))
  }
  
  # Grab appropriate capture data
  capt <- get_capt_by_id(fit, call_id, animal_id, session)
  bincapt <- get_capt_by_id(fit, call_id, animal_id, session, return_bincapt=T)
  
  # Grab our estimated parameters, along with other model fitting parameters
  det_pars <- as.list(coef(fit, type="fitted"))
  det_pars$cutoff <- get_ss.opts(fit)$cutoff
  detfn <- get_detfn(fit)
  ss.link <- get_ss_link(fit)
  traps <- get_trap(fit)[[session]]
  n_traps <- nrow(traps)
  dists <- distances(traps, as.matrix(mask))
  
  # Only allow newdata argument for parameter extended models
  par_extended <- !is.null(get_par_extend(fit))
  if (!is.null(newdata) && !par_extended) {
    stop("'newdata' argument is only available for parameter extended models")
  }
  
  # Deal with extended parameters
  if (par_extended) {
    ext_par_matrices <- get_par_extend_matrix(fit, mask, traps, newdata = newdata)
    det_pars[names(ext_par_matrices)] <- ext_par_matrices
  }
  
  # Coerce singular scalar params to n_traps x n_mask matrix using recycling
  # Makes the density calculation easier 
  for (param_name in c("sigma.ss", "b0.ss", "b1.ss")) {
    if (!is.matrix(det_pars[[param_name]])) {
      det_pars[[param_name]] <- matrix(det_pars[[param_name]], 
                                       nr = n_traps, nc = nrow(mask))
    }
  }
  
  # A list to store each call density, will be combined into one data 
  density_list <- vector("list", length(call_id))
  
  for (i in seq_along(call_id)) {
    cid <- call_id[i]
    
    # Grab the capt & bincapt for this call ID
    sub_capt <- subset(capt, ID == cid)
    # Make sure to remove ID column when doing calculations
    sub_bin  <- subset(bincapt, ID == cid)[,-1] 
    ss.capt <- sub_capt$ss
    triggered_traps <- sub_capt$trap
    untriggered_traps <- setdiff(seq(n_traps), triggered_traps)
    
    # Initialize density matrix for this call
    mask.dens <- matrix(1, nrow = n_traps, ncol = nrow(mask))
    
    # Probability contribution from triggered traps
    mu.ss <- det_pars$b0.ss[triggered_traps, ] - 
      det_pars$b1.ss[triggered_traps, ]*dists[triggered_traps, ]
    mask.dens[triggered_traps, ] <- dnorm(ss.capt, mu.ss, det_pars$sigma.ss[triggered_traps, ])

    # Probability contribution from untriggered traps
    mu.ss <- det_pars$b0.ss[untriggered_traps, ] - 
      det_pars$b1.ss[untriggered_traps, ]*dists[untriggered_traps, ]
    mask.dens[untriggered_traps, ] <- pnorm(det_pars$cutoff, mu.ss, det_pars$sigma.ss[untriggered_traps, ])

    # Multiply all the columns together (triggered and untriggered probabilities)
    mask.dens <- matrixStats::colProds(mask.dens)
    
    density_list[[i]] <- data.frame(
      ID = cid, x = mask[, 1], y = mask[, 2], z = mask.dens
    )
  }
  
  return(do.call(rbind, density_list))
}

#' Calculate the capture history density
#' 
#' Calculates the capture history density of calls from a model fit using 
#' [fit.acre].
#'
#' @inheritParams location_density
#'
#' @return a data frame with columns `x`, `y` and `x`
#' @export
#'
#' @examples
capt_density <- function(fit, call_id, animal_id=NULL, session=1, 
                         mask=get_mask(fit)[[session]]) {
  # Grab appropriate capture data
  capt <- get_capt_by_id(fit, call_id, animal_id, session)
  bincapt <- get_capt_by_id(fit, call_id, animal_id, session, return_bincapt=T)
  
  # Grab our estimated parameters, along with other model fitting parameters
  det_pars <- as.list(coef(fit, type="fitted"))
  detfn <- get_detfn(fit)
  if (fit$fit.types["ss"] || detfn == 'ss') {
    stop("Capture density for signal strength models is built in to the 
         signal strength density. Please use 'ss_density()' instead.")
  }
  traps <- get_trap(fit)[[session]]
  dists <- distances(traps, as.matrix(mask))

  par_extended <- !is.null(get_par_extend(fit))
  
  # Deal with extended parameters
  if (par_extended) {
    ext_par_matrices <- get_par_extend_matrix(fit, mask, traps)
    det_pars[names(ext_par_matrices)] <- ext_par_matrices
  }
  
  # A list to store each call density, will be combined into one data 
  density_list <- vector("list", length(call_id))
  
  for (i in seq_along(call_id)) {
    cid <- call_id[i]
    
    # Grab the capt & bincapt for this call ID
    sub_capt <- subset(capt, ID == cid)
    # Make sure to remove ID column when doing calculations
    sub_bin  <- as.numeric(subset(bincapt, ID == cid)[,-1]) 
    
    # Probability of detection at each mask point
    # Worth noting that `det_prob()` is set up in such a way, that we can
    # pass matrix of n_traps x n_mask as parameter values, and get corresponding
    # n_traps x n_mask detection probabilities back.
    det.probs <- det_prob(detfn, det_pars, dists)
    
    # Density due to capture history alone
    capt_dens <- apply((det.probs ^ sub_bin) * 
                         ((1 - det.probs) ^ (1 - sub_bin)), 2, prod)
    
    density_list[[i]] <- data.frame(
      ID = cid, x = mask[, 1], y = mask[, 2], z = capt_dens
    )
  }
  
  return(do.call(rbind, density_list))
}

#' Calculate the detection surface density
#' 
#' Calculates the detection surface density for a model fit using 
#' [fit.acre].
#' 
#' See: https://research-repository.st-andrews.ac.uk/bitstream/handle/10023/18233/BenStevensonPhDThesis.pdf
#' (Equation 1.4)
#'
#' @inheritParams location_density
#' @return a data frame with columns `x`, `y` and `Dsurface_density`
#' @export
#'
#' @examples
Dsurface_density <- function(fit, session=1, mask=get_mask(fit)[[session]]) {
  # Grab estimated parameters, along with other model fitting variables
  det_pars <- as.list(coef(fit, type="fitted"))
  detfn <- get_detfn(fit)
  if (fit$fit.types["ss"]) {
    det_pars$cutoff <- get_ss.opts(fit)$cutoff
  }
  ss_link <- get_ss_link(fit)
  traps <- get_trap(fit)[[session]]
  a <- attr(mask, "area")

  par_extended <- !is.null(get_par_extend(fit))
  
  # Deal with extended parameters
  if (par_extended) {
    ext_par_matrices <- get_par_extend_matrix(fit, mask, traps)
    det_pars[names(ext_par_matrices)] <- ext_par_matrices
  }
  
  # Calculating detection probabilities
  prob_det_total <- p.dot.defaultD(as.matrix(mask), traps, detfn, ss_link, 
                                   det_pars, a)
  prob_det <- p.dot.defaultD(as.matrix(mask), traps, detfn, ss_link, det_pars, a, 
                             esa = F)
  
  # Calculating location density
  if (fit$fit.ihd){
    if (TRUE) { #is.null(newdata)
      # Note that intensity mask is simply our estimated density at each mask
      # point
      intensity_mask <- fit$D.mask[[session]]
    } else {
      # Density cannot be trap-level extended, so take the first row as all the 
      # rows will be identical
      intensity_mask <- det_pars$D[1, ]
    }
    z <- (prob_det * intensity_mask) / (a * sum(prob_det * intensity_mask))
  } else {
    # Note that prob_det_total is already multiplied by `a` in p.dot.defaultD()
    z <- prob_det / prob_det_total
  }
  
  density.df <- data.frame(
    x = mask[, 1],
    y = mask[, 2],
    z = z
  )
  
  return(density.df)
}

plot_contour <- function(x, y, dens, n_levels, filled=FALSE, ...) {
  # Prepare data for contour plotting
  # Requires no duplicate x or y
  unique.x <- sort(unique(x))
  unique.y <- sort(unique(y))
  
  # Assigns every x, y to the corresponding matrix row / col
  # Match returns the first position where the values match
  row_id <- match(x, unique.x)
  col_id <- match(y, unique.y)
  
  # Assign each density to corresponding matrix index
  z <- matrix(NA_real_, nrow = length(unique.x), ncol = length(unique.y))
  z[cbind(row_id, col_id)] <- dens
  
  # Tried using pretty() but its inconsistent output is annoying
  dens_range <- range(dens)
  levels <- seq(from = dens_range[1], to = dens_range[2], 
                length.out = n_levels + 1)
  
  # Convert density breaks to probabilities
  # Raw density levels aren't meaningful to typical user
  probability_labels <- character(n_levels + 1)
  for (i in 1:(n_levels + 1)){
    probability_labels[i] <- format(
      round(sum(dens[dens > levels[i]]) / sum(dens), 2), 
      nsmall = 2)
  }
  
  # Plot the contours
  if (filled) {    
    # Interpolating to a grid for higher resolution
    grid <- list(
      x = seq(min(unique.x), max(unique.x), length = 500),
      y = seq(min(unique.y), max(unique.y), length = 500)
    )
    
    surf <- fields::interp.surface.grid(
      obj  = list(x = unique.x, y = unique.y, z = z),
      grid = grid
    )
    
    # Without grid ==> fields::imagePlot(x = unique.x, y = unique.y, z = z, ...)
    fields::imagePlot(x = grid$x, y = grid$y, z = surf$z, 
                      col = faded_virdis(n_levels), 
                      xlim = range(x), ylim = range(y), 
                      xlab = "x", ylab = "y", 
                      legend.width = 2, legend.line = 4, 
                      legend.lab = "Probability", legend.shrink = 1, 
                      legend.mar = 6,
                      breaks = levels, lab.breaks = probability_labels)
    
    contour(x = unique.x, y = unique.y, z = z, levels = levels,
            labels = probability_labels, add = TRUE, 
            col=faded_virdis(n_levels, max_alpha = 0.6), 
            lwd=1, drawlabels = F, ...)
    
  } else {
    contour(x = unique.x, y = unique.y, z = z, levels = levels, 
            labels = probability_labels, drawlabels = TRUE, add = TRUE, 
            asp=1, ...)
  }
}

plot_locations <- function(fit, call_id = NULL, animal_id = NULL, session=1, 
                           filled=FALSE, n_levels=8, add=FALSE) {
  if (add & filled) {
    stop("filled contours cannot be added to existing plots")
  }
  # If `call_id` is not passed, assume we want to plot all the unique calls
  if (is.null(call_id)) {
    call_id <- unique(get_capt_by_id(fit, "all", animal_id, session)$ID)
  } 
  
  mask <- get_mask(fit)[[session]]
  
  for (cid in call_id) {
    # Calculate densities for this call
    dens <- location_density(fit, cid, animal_id, session = session)
    
    # Plot the density contours 
    if (filled) {
      plot_contour(dens$x, dens$y, dens$combined_density, n_levels, filled = TRUE)
    } else {
      if (!add) {
        plot(NA, xlim = range(mask[, 1]), ylim = range(mask[, 2]), asp = 1,
             xlab = "x", ylab = "y")
      }
      plot_contour(dens$x, dens$y, dens$combined_density, n_levels)
    }
    
    # Plot all the additional capture information
    # Traps
    plot_traps(fit, cid, animal_id, session)
    # Bearing arrows
    if ("bearing" %in% fit$infotypes) {
      plot_bearing_arrows(fit, cid, animal_id, session)
    } 
    # Distance circles - only if no bearings
    else if ("dist" %in% fit$infotypes) {
      plot_distance_circles(fit, cid, animal_id, session)
    }
    # TOA order
    if ("toa" %in% fit$infotypes) {
      plot_toa_order(fit, cid, animal_id, session)
    }
    
    # Title
    if (!add) {
      plot_title <- create_locations_plot_title(cid, animal_id, session)
      title(plot_title)  
    }
    
    if (length(call_id) > 1 && cid != call_id[[length(call_id)]]) {
      prompt_user_for_next_plot()
    } 
  }
}

#' Create a plot subtitle for [plot_location_density]
#'
#' @inheritParams location_density
#'
#' @return a string to use as plot subtitle
#'
#' @examples
create_locations_plot_title <- function(call_id, animal_id, session) {
  if (is.null(animal_id)) {
    subtitle = paste0("session: ", session, ", call ID: ", call_id)
  } else {
    if (length(call_id) == 1) {
      subtitle = paste0("session: ", session, ", animal ID: ", animal_id,
                        ", call ID: ", call_id)
    } else {
      subtitle = paste0("session: ", session, ", animal ID: ", animal_id)
    }
  }
  
  return(subtitle)
}


