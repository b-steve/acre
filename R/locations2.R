#' Calculate location density
#' 
#' Calculates the estimated density of a location, given its observed capture 
#' history and auxiliary information.
#'
#' @param fit an object generated from the model fitting function 
#'    \link{fit.acre} or the bootstrap process \link{boot.acre}.
#' @param call_id an numeric vector indicating which call ID's to calculate
#'    density for.
#' @param animal_id an numeric value indicating animal ID. Should only be 
#'    specified if \code{fit} is an \code{animalID} model.
#' @param session an integer value indicating the detector array and 
#'    individual(s) to be plotted. 
#' @param mask a list or a data frame. Generated by \link{create.mask()}.
#' @param warn_toa a logical value indicates whether to issue warning in the 
#'    case of \code{toa} data with only a single call.
#' @param newdata data.frame; contains any covariates that will be used 
#'    for all extended parameters.
#'
#' @return 
#' @export 
#'
#' @examples
location_density <- function(fit, call_id, animal_id=NULL, session=1, 
                              mask=get_mask(fit)[[session]], warn_toa=F, 
                              newdata=NULL) {
  # Note input validation for call_id, animal_id, session
  # is handled in `get_capt_by_id()`
  
  density_types <- c(fit$infotypes, "capt", "Dsurface")
  
  # Note each density function returns a df with columns:
  #   ID, x, y, [density_name]_density
  density_list <- lapply(density_types, function(d_type) {
    switch(
      d_type,
      "Dsurface" = Dsurface_density(fit, session, mask, newdata),
      "capt" = capt_density(fit, call_id, animal_id, session, mask),
      "toa"  = toa_density(fit, call_id, animal_id, session, mask,
                           warn=warn_toa),
      "dist" = dist_density(fit, call_id, animal_id, session, mask),
      "ss"   = ss_density(fit, call_id, animal_id, session, mask),
      "bearing" = bearing_density(fit, call_id, animal_id, session, mask),
      stop(paste0("Unknown density type: '", d_type, 
                  "', currently supported types are: 'capt', 'ss', 'dist',
                   'bearing', 'toa', 'Dsurface'."))
    )
  })
  
  # For clarity
  names(density_list) <- density_types
  
  # Keep the three key columns only once
  base_cols <- density_list[[1]][, c("ID", "x", "y")]
  
  # Pull the single density column from each data frame
  dens_mat <- do.call(
    cbind,
    lapply(density_list, `[`, "z")
  )
  
  # Rename those columns to match the density types
  colnames(dens_mat) <- paste0(density_types, "_density")
  
  # final data frame
  merged_densities <- cbind(base_cols, dens_mat)
  
  # Create the combined density column by multiplying all density columns 
  merged_densities$combined_density <- Reduce(`*`, merged_densities[-c(1:3)])
  
  # Return the final data frame
  return(merged_densities)
}

#' Plot location density
#' 
#' A helper function provided to quickly plot location density.
#' 
#' If you want more customization of the plot, please consider using 
#' \link{location_density} as well as any of plot helper functions:
#' - \link{plot_traps}
#' - \link{plot_toa_order}
#' - \link{plot_bearing_arrows}
#' - \link{plot_distance_circles}
#'
#' @inheritParams location_density
#' @param plot_types a vector which is a subset of 
#'    \code{c("capt", "ss", "dist", "bearing", "toa", "Dsurface", "combined")}
#' @param joint a logical value indicating whether to plot the joint density.
#'    Only applicable to animal ID models. Not yet implemented.
#' @param nlevels a numeric value indicating the number of contour lines to
#'    plot.
#' @param ann a logical value indicating whether to include plot annotation.
#' @param ask a logical value indicating whether to prompt user for subsequent
#'    plot.
#' @param display_plot a logical value indicating whether to display the plot.
#'
#' @return a ggplot object corresponding to the most recently constructed plot.
#' @export
#'
#' @examples
plot_location_density <- function(fit, call_id="all", animal_id=NULL, session=1, 
                      mask=get_mask(fit)[[session]],  newdata=NULL,
                      plot_types="combined", joint=F, nlevels=8, ann=T,
                      ask = interactive(), display_plot=T) {
  # Note input validation for call_id, animal_id, session
  # is handled in `get_capt_by_id()`
  
  # Don't think it's worth separating this out
  valid_plot_types <- c("capt", "ss", "dist", "bearing", "toa", "Dsurface", 
                        "combined")
  if (!all(plot_types %in% valid_plot_types)) {
    stop(paste0("The only plot types supported are: \"", 
                paste0(valid_plot_types, collapse = "\", \""), "\""))
  }
  if (!all(plot_types %in% c(fit$infotypes, "capt", "Dsurface", "combined"))) {
    stop(paste0("The only plot types available for this fit are: \"", 
                paste0(c(fit$infotypes, "capt", "Dsurface", "combined"), 
                       collapse = "\", \""), "\""))
  }
  
  if (!display_plot && (length(call_id) > 1 || identical(call_id, "all"))) {
    stop("'display_plot' must be true if multiple call ID's are provided")
  }
  
  if (identical(call_id, "all")) {
    call_id <- unique(get_capt_by_id(fit, call_id, animal_id, session)$ID)
  }
  
  # isTRUE() for clarity? Never used it before, but might start using it.
  # Check if we are using a mask different than the one used to fit the model.
  # If so, we need to make sure the new loc covariates are provided if IHD.
  is.new.mask <- !identical(unclass(mask), unclass(get_mask(fit)[[session]]))
  if (isTRUE(fit$fit.ihd) && is.new.mask && is.null(newdata)){
    stop("Covariate values for the new mask object must be provided via the 
         'newdata' argument.")
  }
  
  density_cols <- c(
    "capt" = "black",
    "bearing" = "red",
    "dist" = "green",
    "combined" = "blue",
    "ss" = "orange",
    "toa" = "purple",
    "Dsurface" = "gray70"
  )
  
  # For each call
  for (i in seq_along(call_id)) {
    cid <- call_id[i]
    
    # Calculate combined density by default, rather than bloating function args
    call_densities <- location_density(fit, cid, animal_id, session, mask = mask,
                                       warn_toa = F, 
                                       newdata = newdata)
    
    # 2) Initialize a base ggplot, might need to be coord_sf() if issues pop up
    p <- ggplot(call_densities, aes(x = x, y = y)) +
      ggplot2::coord_equal(xlim = range(mask[,1]), ylim = range(mask[,2]))
    
    if (ann) {
      p <- p + ggtitle(paste("Location density -", substitute(fit))) +
        labs(subtitle = create_locations_plot_subtitle(cid, animal_id, session))
    }
    
    for (d_type in plot_types) {
      # What is the right way to do this, because there is no way it is this
      density_column <- paste0(d_type, "_dens")
      
      # Note that we can't calculate / plot TOA densities in the case of only a
      # single trap detection. If this is the case, toa_density() returns an 
      # equal density across mask, so just check for that, rather than reading
      # in all the capt data.
      if (d_type == "toa" & 
          length(unique(call_densities[[density_column]])) == 1) {
        # If we are ONLY plotting toa for 1 call stop, otherwise just warn 
        if (length(call_id) == 1 & length(plot_types) == 1) {
          stop(paste0("Could not plot toa density for call: ", cid, 
                      ". Calls must be detected on at least 2 traps to use toa data."))
        } else {
          message("Could not plot toa density for call: ", cid, 
                  ". Calls must be detected on at least 2 traps to use toa data.")
          next
        }
      }
      
      # Add contours
      # If we are only plotting a single density type, use a filled contour, 
      # otherwise use line contours.
      density_column_index <- which(colnames(call_densities) == density_column)
      contour.df <- call_densities[,c(2,3,density_column_index)]
      # Need to set the density column name to "z"
      colnames(contour.df)[3] <- "z"
      contour.df$density_type <- d_type
      
      
      p <- p + geom_contour_helper(contour.df,
                            filled = length(plot_types) == 1,
                            nlevels = nlevels, prob = T)
    }
    
    # Add traps
    p <- p + plot_traps(fit, cid, animal_id, session, circle_traps = T)
    
    # Add bearing arrows
    if ("bearing" %in% plot_types || 
        ("combined" %in% plot_types && "bearing" %in% fit$infotypes)) {
      p <- p + plot_bearing_arrows(fit, cid, animal_id, session)
    }
    
    # Add distance circles
    if ("dist" %in% plot_types) {
      p <- p + plot_distance_circles(fit, cid, animal_id, session)
    }
    
    # Add toa indicators
    if ("toa" %in% plot_types) {
      p <- p + plot_toa_order(fit, cid, animal_id, session)
    }
    
    # Add ss indicators (not sure how I feel about this one right now)
    # if ("ss" %in% plot_types) {
    #   p <- p + plot_ss_indicators(fit, cid, animal_id, session)
    # }
    
    # Is this cleaner?
    # p <- p +
    #   plot_traps(fit, cid, animal_id, session, circle_traps = TRUE) +
    #   if ("bearing" %in% plot_types) plot_bearing_arrows(fit, cid, animal_id, session) +
    #   if ("dist" %in% plot_types) plot_distance_circles(fit, cid, animal_id, session) +
    #   if ("toa" %in% plot_types) plot_toa_order(fit, cid, animal_id, session)
    
    if (length(plot_types) > 1) {
      p <- p + ggplot2::scale_colour_manual(
        name = "Density type",
        values = density_cols
      )
    }
      

    p <- p + ggplot2::theme_bw()
    
    # Remove legend and axis if necessary
    if (!ann) {
      p <- p + ggplot2::theme(legend.position="none",      
                              axis.text.x=ggplot2::element_blank(),
                              axis.text.y=ggplot2::element_blank(),
                              axis.title.x=ggplot2::element_blank(),
                              axis.title.y=ggplot2::element_blank())
    }
    
    # Display plot
    if (display_plot) {
      print(p)
    }
    
    # Make sure to only prompt user if we are plotting more than one plot, 
    # and it is not the last plot in the list
    if (ask && display_plot) {
      if (length(call_id) > 1 && cid != call_id[[length(call_id)]]) {
        prompt_user_for_next_plot()
      }  
    }
  }
  
  invisible(p)
}

#' Calculate density breaks for given probabilities
#' 
#' Calculates breaks for a given density map from provided probability bins.
#'
#' @param dens a vector of probability densities.
#' @param probability_breaks the probabilities at which to calculate density 
#'    breaks.
#'
#' @return
#'
#' @examples
get_density_breaks_from_probability <- function(dens, probability_breaks) {
  dens.sort <- sort(dens, decreasing = TRUE)
  probs.sort <- cumsum(dens.sort)/sum(dens.sort)
  prob.levels <- probability_breaks
  levels <- numeric(length(prob.levels))
  for (i in 1:length(prob.levels)){
    levels[i] <- dens.sort[which(abs(probs.sort - prob.levels[i]) ==
                                min(abs(probs.sort - prob.levels[i])))[1]]
  }
  
  return(levels)
}

#' Construct location density plot contours
#' 
#' A helper function to construct the contours used in 
#' \link{plot_location_density}
#'
#' @param dens a vector of probability densities.
#' @param filled a logical value indicating whether the contour should be 
#'    a filled or line contour.
#' @param nlevels a numeric value indicating the number of contour lines to
#'    plot.
#' @param prob a logical value indicating whether the contours labels should be 
#'    displayed as probabilities or density intervals.
#'
#' @return a list containing ggplot \code{geom_contour} object, as well as a 
#'    \code{scale_fill_manual} object in the case of filled contours.
#'
#' @examples
geom_contour_helper <- function(dens, filled=T, nlevels=8, prob=F) {
  # Tried using pretty() but its inconsistent output is annoying
  dens_range <- range(dens$z)
  levels <- seq(from = dens_range[1], to = dens_range[2], length.out = nlevels+1)
  
  # It might seem strange constructing the scale function arguments like this,
  # but doing so allows us to leave the "labels" field blank in the case of 
  # non-probability contours (prob=F), and use the ggplot default legend labels.
  scale_args <- list()
  
  # If we want probability labels
  if (prob) {
    probability_labels <- character(nlevels)
    for (i in 1:nlevels){
      probability_labels[i] <- format(
        round(sum(dens$z[dens$z > levels[i]]) / sum(dens$z), 2), 
        nsmall = 2)
    }
    
    scale_args$name <- "Probability"
    scale_args$labels <- probability_labels
  } else {
    # Otherwise use the default density labels
    scale_args$name <- "Density"
  }
    
  if (filled) {
    # base_colors <- rep(color, nlevels)
    base_colors <- viridisLite::viridis(nlevels)
    alpha_values <- seq(0, 1, length.out = nlevels)
    faded_colors <- unlist(
      Map(function(col, a) scales::alpha(col, a), base_colors, alpha_values)
    )
    scale_args$values = unname(faded_colors)
    
    return(
      list(
        ggplot2::geom_contour_filled(
          aes(z = dens$z),
          # colour = "white",
          colour = NA,
          # bins = 8,
          breaks = levels,
          linewidth=0.5
        ),
        do.call(ggplot2::scale_fill_manual, scale_args)
      )
    )
  } else {
    return(ggplot2::geom_contour(
      data = dens,
      aes(z = z, color = density_type),
      # colour = color,
      alpha = 0.7,
      breaks = levels,
      bins = 15
    ))
  }
}

#' Creates ggplot \code{geom_point} traps of a fitted \code{acre} model
#' 
#' Creates crosses at trap locations. Optionally circles triggered traps for a 
#' given call. 
#'
#' @inheritParams location_density
#' @param circle_traps a logical value indicating whether or not triggered traps 
#'    should be circled. If \code{TRUE}, \code{call_id} (and \code{animal_id} in
#'    the case of animal ID models) must be provided. 
#'
#' @return a list containing either 1 or 2 ggplot \code{geom_point} objects, 
#'    depending on whether \code{circle_traps = T}.  
#' @export
#'
#' @examples
plot_traps <- function(fit, call_id=NULL, animal_id=NULL, session=1, circle_traps=F, col="red") {
  traps <- get_trap(fit)[[session]]
  
  trap_points <- geom_point(data = traps, mapping = aes(x = x, y = y), 
             size = 3, col=col, stroke=1, shape = 4)
  
  if (circle_traps) {
    if (length(call_id) > 1 | !is.numeric(call_id)) {
      stop(paste("'call_id' must be a single numeric value.", 
                 "Plotting traps is only supported for single calls."))
    }
    
    # Grab appropriate capture data
    bincapt <- get_capt_by_id(fit, call_id, animal_id, session, return_bincapt = T)[,-1]
    
    trap_circles <- geom_point(
      data = subset(traps, bincapt == 1), aes(x = x, y = y),
      shape = 21, color = col, size = 4.5, stroke = 1)
    
    return(list(trap_points, trap_circles))
  } else {
    return(trap_points)
  }
}

#' Creates ggplot \code{geom_text} annotations of \code{toa} data
#' 
#' Annotates traps, in order of the time of arrival of the call. 1 for the first
#' trap to receive the call, 2 for the second...
#'
#' @inheritParams location_density
#'
#' @return a ggplot \code{geom_text} object.
#' @export
#'
#' @examples
plot_toa_order <- function(fit, call_id, animal_id=NULL, session=1) {
  if (length(call_id) > 1 | !is.numeric(call_id)) {
    stop(paste("'call_id' must be a single numeric value.", 
               "Plotting toa indicators is only supported for single calls."))
  }
  
  if (!("toa" %in% fit$infotypes)) {
    stop("'fit' does not contain toa information.")
  }
  
  # Grab appropriate capture data
  capt <- get_capt_by_id(fit, call_id, animal_id, session)
  
  # Need at least 2 trap detections to use toa
  if (nrow(capt) < 2) {
    return()
  } else{
    traps <- get_trap(fit)[[session]]
    toa_order <- rank(capt$toa, ties.method = "min")
    
    return(ggplot2::geom_text(data = traps[capt$trap,], 
                              aes(x = x, y = y, label = toa_order),
                              size = 2, vjust = 1.5, hjust=-2, colour = "black"))
  }
  

}

#' Creates ggplot \code{geom_segment} object representing call bearings
#' 
#' Creates arrows which point in the direction of the call bearings. Arrow
#' origins are equal to the corresponding triggered trap location.
#'
#' @inheritParams location_density
#'
#' @return a list containing a ggplot \code{geom_segment} object.
#' @export
#'
#' @examples
plot_bearing_arrows <- function(fit, call_id, animal_id=NULL, session=1) {
  if (length(call_id) > 1 | !is.numeric(call_id)) {
    stop(paste("'call_id' must be a single numeric value.", 
               "Plotting ebaring arrows is only supported for single calls."))
  }
  
  # Make sure call_id is a single numeric
  if (length(call_id) > 1 | !is.numeric(call_id)) {
    stop(paste("'call_id' must be a single numeric value.", 
               "Plotting bearing arrows is only supported for single calls."))
  }
  
  if (!("bearing" %in% fit$infotypes)) {
    stop("'fit' does not contain bearing information.")
  }
  
  # Grab appropriate capture data
  capt <- get_capt_by_id(fit, call_id, animal_id, session)
  bincapt <- get_capt_by_id(fit, call_id, animal_id, session, return_bincapt=T)[,-1]
  
  is.dist <- "dist" %in% fit$infotypes
  traps <- get_trap(fit)[[session]]
  activated_traps <- subset(traps, bincapt == 1)
  bearing <- capt$bearing
  dist <- capt$dist
  
  # Set appropriate arrow length. Default to 1/3 buffer radius.
  arrow_len <- rep(0.333 * get_buffer(fit)[session], length(capt$bearing))
  if (is.dist) {
    # Account for the possibility that dist may be NA for some captures
    arrow_len[!is.na(capt$dist)] <- capt$dist[!is.na(capt$dist)]
  }
  
  sinb <- sin(bearing)*arrow_len
  cosb <- cos(bearing)*arrow_len
  
  arrows.df <- data.frame(
    x = activated_traps[, 1],
    y = activated_traps[, 2],
    xend = activated_traps[, 1] + sinb,
    yend = activated_traps[, 2] + cosb
  )
  
  # Remove any NA bearing captures
  arrows.df <- arrows.df[complete.cases(arrows.df), ]
  
  return(geom_segment(data = arrows.df, 
                      mapping = aes(x = x, y = y, xend = xend, yend = yend),
                      col="red",
                      arrow = arrow(length = ggplot2::unit(0.2, "cm")) # Arrow head 
                      )
         ) 
}

#' Creates ggplot \code{geom_path} object representing call distance
#' 
#' Creates circles which have radius equal to the recorded distance for each 
#' call. The circles are centered around the corresponding triggered traps 
#' location.
#'
#' @inheritParams location_density
#'
#' @return a list containing a ggplot \code{geom_path} object.
#' @export
#'
#' @examples
plot_distance_circles <- function(fit, call_id, animal_id=NULL, session=1) {
  # Make sure call_id is a single numeric
  if (length(call_id) > 1 | !is.numeric(call_id)) {
    stop(paste("'call_id' must be a single numeric value.", 
               "Plotting distance circles is only supported for single calls."))
  }
  
  if (!("dist" %in% fit$infotypes)) {
    stop("'fit' does not contain distance information.")
  }
  
  # Grab appropriate capture data
  capt <- get_capt_by_id(fit, call_id, animal_id, session)
  bincapt <- get_capt_by_id(fit, call_id, animal_id, session, return_bincapt=T)[,-1]
  dist <- capt$dist
  traps <- get_trap(fit)[[session]]
  activated_traps <- subset(traps, bincapt == 1)
  
  # Remove NA distances
  keep <- !is.na(capt$dist)
  # Note the drop=FALSE keeps the data structure; makes easier to loop over
  activated_traps <- activated_traps[keep, , drop = FALSE]
  dists <- capt$dist[keep]
  
  circles.df <- do.call(
    rbind,
    lapply(seq_len(nrow(activated_traps)), function(i) {
      out <- circle_fun(activated_traps[i, ], diameter = 2 * dists[i])
      out$circle_id <- i
      out
    })
  )
  
  return(list(
      geom_path(
        data = circles.df,
        aes(x, y, group = circle_id),
        colour = "red",
        linewidth = 0.4,
        linetype = "dashed"
      )
    )
  )
}

#' Creates ggplot \code{geom_point} object representing call signal strength
#' 
#' Creates blue circles, which get darker based on signal strength intensity.
#' Not currently implemented as it does not add much to the plotting.
#'
#' @inheritParams location_density
#'
#' @return a list containing ggplot \code{geom_point} objects, as well as a 
#'    \code{guides} object.  
#' @export
#'
#' @examples
plot_ss_indicators <- function(fit, call_id, animal_id, session=1) {
  if (length(call_id) > 1 | !is.numeric(call_id)) {
    stop(paste("'call_id' must be a single numeric value.", 
               "Plotting ss indicators is only supported for single calls."))
  }
  
  if (!("ss" %in% fit$infotypes)) {
    stop("'ss' does not contain toa information, cannot plot ss indicators.")
  }
  
  # Grab appropriate capture data
  capt <- get_capt_by_id(fit, call_id, animal_id, session)
  traps <- get_trap(fit)[[session]]
  
  return(list(geom_point(data = traps[capt$trap,], 
                         mapping = aes(x = x, y = y, colour = capt$ss), 
                         size = 5), 
              guides(colour = guide_colourbar(order = 1, 
                                              title = "Signal Strength"))
  )
  )
}

#' Calculate the distance density
#' 
#' Calculates the distance density of calls from a model fit using 
#' \link{fit.acre}.
#'
#' @inheritParams location_density
#' @param dists a distance matrix created using \link{distances}. If not 
#'    provided, it will be calculated automatically.
#'
#' @return a data frame with columns \code{x}, \code{y} and \code{dist_dens}
#' @export
#'
#' @examples
dist_density <- function(fit, call_id, animal_id=NULL, session=1, 
             mask=get_mask(fit)[[session]], dists=NULL) {
  # Note input validation for call_id, animal_id, session
  # is handled in `get_capt_by_id()`
  
  if (!("dist" %in% fit$infotypes)) {
    stop(paste0("'fit' does not contain 'dist' information. ",
                "Infotypes available for the fit provided are: ", 
                paste0(fit$infotypes, collapse=", "), ", Dsurface, capt"))
  }
  
  # Grab appropriate capture data
  capt <- get_capt_by_id(fit, call_id, animal_id, session)
  bincapt <- get_capt_by_id(fit, call_id, animal_id, session, return_bincapt=T)
  
  # Perhaps need to add some validation for dists & mask
  if (is.null(dists)) {
    traps <- get_trap(fit)[[session]]
    dists <- distances(traps, as.matrix(mask))
  }

  # Grab our estimated alpha parameter
  alpha <- coef(fit, type="fitted")[["alpha"]]
  betas <- alpha/dists
  
  # A list to store each call density, will be combined into one data 
  density_list <- vector("list", length(call_id))
  
  for (i in seq_along(call_id)) {
    cid <- call_id[i]
    
    # Grab the capt & bincapt for this call ID
    sub_capt <- subset(capt, ID == cid)
    # Make sure to remove ID column when doing calculations
    sub_bin  <- subset(bincapt, ID == cid)[,-1] 
    dist.capt <- sub_capt$dist
    
    # Initialize density matrix for this call
    mask.dens <- matrix(1, nrow = sum(sub_bin), ncol = nrow(mask))
    
    # Calculate density for each triggered trap
    for (j in 1:sum(sub_bin)) {
      if (!is.na(dist.capt[j])) {
        mask.dens[j, ] <- dgamma(dist.capt[j], shape = alpha, rate = betas[j, ])
      }
    }
    
    mask.dens <- apply(mask.dens, 2, prod)

    density_list[[i]] <- data.frame(
      ID = cid, x = mask[, 1], y = mask[, 2], z = mask.dens
    )
  }

  return(do.call(rbind, density_list))
}


#' Calculate the bearing density
#' 
#' Calculates the bearing density of calls from a model fit using 
#' \link{fit.acre}.
#'
#' @inheritParams location_density
#'
#' @return a data frame with columns \code{x}, \code{y} and \code{bearing_dens}
#' @export
#'
#' @examples
bearing_density <- function(fit, call_id, animal_id=NULL, session=1, 
                         mask=get_mask(fit)[[session]]) {
  # Note input validation for call_id, animal_id, session
  # is handled in `get_capt_by_id()`
  
  if (!("bearing" %in% fit$infotypes)) {
    stop(paste0("'fit' does not contain 'bearing' information. ",
                "Infotypes available for the fit provided are: ", 
                paste0(fit$infotypes, collapse=", "), ", Dsurface, capt"))
  }
  
  # Grab appropriate capture data
  capt <- get_capt_by_id(fit, call_id, animal_id, session)
  bincapt <- get_capt_by_id(fit, call_id, animal_id, session, return_bincapt=T)
  traps <- get_trap(fit)[[session]]
  
  # Grab our estimated kappa parameter
  kappa <- coef(fit, type="fitted")[["kappa"]]
  
  # A list to store each call density, will be combined into one data 
  density_list <- vector("list", length(call_id))
  
  for (i in seq_along(call_id)) {
    cid <- call_id[i]
    
    # Grab the capt & bincapt for this call ID
    sub_capt <- subset(capt, ID == cid)
    # Make sure to remove ID column when doing calculations
    sub_bin  <- subset(bincapt, ID == cid)[,-1] 
    bearing.capt <- sub_capt$bearing
    
    # Initialize density matrix for this call
    mask.dens <- matrix(1, nrow = sum(sub_bin), ncol = nrow(mask))
    
    # Calculate bearings for each triggered trap
    mask.bearings <- bearings(subset(traps, sub_bin == 1), as.matrix(mask))
    
    # Calculate the density for each triggered trap
    for (j in 1:sum(sub_bin)) {
      # Make sure bearing isn't missing
      if (!is.na(bearing.capt[j])) {
        mask.dens[j, ] <- CircStats::dvm(bearing.capt[j], 
                                         mu = mask.bearings[j, ], kappa = kappa)
      }
    }
    
    mask.dens <- apply(mask.dens, 2, prod)
    
    density_list[[i]] <- data.frame(
      ID = cid, x = mask[, 1], y = mask[, 2], z = mask.dens
    )
  }
  
  return(do.call(rbind, density_list))
}

#' Calculate the time of arrival density
#' 
#' Calculates the time of arrival density of calls from a model fit using 
#' \link{fit.acre}.
#'
#' @inheritParams location_density
#' @param dists a distance matrix created using \link{distances}. If not 
#'    provided, it will be calculated automatically.
#'
#' @return a data frame with columns \code{x}, \code{y} and \code{toa_dens}
#' @export
#'
#' @examples
toa_density <- function(fit, call_id, animal_id=NULL, session=1, 
                        mask=get_mask(fit)[[session]], dists=NULL, warn=T) {
  # Note input validation for call_id, animal_id, session
  # is handled in `get_capt_by_id()`
  
  if (!("toa" %in% fit$infotypes)) {
    stop(paste0("'fit' does not contain 'toa' information. ",
                "Infotypes available for the fit provided are: ", 
                paste0(fit$infotypes, collapse=", "), ", Dsurface, capt"))
  }
  
  # Grab appropriate capture data
  capt <- get_capt_by_id(fit, call_id, animal_id, session)
  bincapt <- get_capt_by_id(fit, call_id, animal_id, session, return_bincapt=T)
  traps <- get_trap(fit)[[session]]
  
  # Perhaps need to add some validation for dists & mask
  if (is.null(dists)) {
    traps <- get_trap(fit)[[session]]
    dists <- distances(traps, as.matrix(mask))
  }
  
  # Grab our estimated sigma.toa parameter
  sigma.toa <- coef(fit, type="fitted")[["sigma.toa"]]
  
  # A list to store each call density, will be combined into one data 
  density_list <- vector("list", length(call_id))
  
  # Set to true if there was a capture history with only 1 detection
  # (need at least 2 detections to be able to use toa)
  single_trap_detection = F
  for (i in seq_along(call_id)) {
    cid <- call_id[i]
    
    # Grab the capt & bincapt for this call ID
    sub_capt <- subset(capt, ID == cid)
    # Make sure to remove ID column when doing calculations
    sub_bin  <- subset(bincapt, ID == cid)[,-1] 
    toa.capt <- sub_capt$toa
    
    if (sum(sub_bin) < 2) {
      single_trap_detection = T
      mask.dens <- 1
    } else {
      dists.mask <- dists[sub_bin == 1, ]
      prod.times <- toa.capt - dists.mask/fit$args$sound.speed
      toa.ssq <- apply(prod.times, 2, function(x) sum((x - mean(x))^2))
      mask.dens <- (2*pi*sigma.toa^2)^((1 - sum(sub_bin))/2)*
        exp(toa.ssq/(-2*sigma.toa^2))
    }

    density_list[[i]] <- data.frame(
      ID = cid, x = mask[, 1], y = mask[, 2], z = mask.dens
    )
  }
  
  if (warn & single_trap_detection) {
    warning(paste("Some calls were detected by only a single trap. 
                  The use of toa data requires a call to be detected by at least 
                  2 traps. Toa density for corresponding calls has beem set to 1 
                  across the entire mask for such cases."))
  }
  return(do.call(rbind, density_list))
}

#' Calculate the signal strength density
#' 
#' Calculates the signal strength density of calls from a model fit using 
#' \link{fit.acre}.
#'
#' @inheritParams location_density
#' @param dists a distance matrix created using \link{distances}. If not 
#'    provided, it will be calculated automatically.
#'
#' @return a data frame with columns \code{x}, \code{y} and \code{ss_dens}
#' @export
#'
#' @examples
ss_density <- function(fit, call_id, animal_id=NULL, session=1, 
                        mask=get_mask(fit)[[session]], dists=NULL) {
  # Note input validation for call_id, animal_id, session
  # is handled in `get_capt_by_id()`
  
  if (!("ss" %in% fit$infotypes)) {
    stop(paste0("'fit' does not contain 'ss' information. ",
                "Infotypes available for the fit provided are: ", 
                paste0(fit$infotypes, collapse=", "), ", Dsurface, capt"))
  }
  
  # Grab appropriate capture data
  capt <- get_capt_by_id(fit, call_id, animal_id, session)
  bincapt <- get_capt_by_id(fit, call_id, animal_id, session, return_bincapt=T)
  
  # Grab our estimated parameters, along with other model fitting parameters
  cutoff <- get_ss.opts(fit)$cutoff
  sigma.ss <- coef(fit, type="fitted")[["sigma.ss"]]
  b1.ss <- coef(fit, type="fitted")[["b1.ss"]]
  b0.ss <- coef(fit, type="fitted")[["b0.ss"]]
  detfn <- get_detfn(fit)
  ss.link <- get_ss_link(fit)
  traps <- get_trap(fit)[[session]]
  n.traps <- nrow(traps)
  
  # Perhaps need to add some validation for dists & mask
  if (is.null(dists)) {
    dists <- distances(traps, as.matrix(mask))
  }
  
  # A list to store each call density, will be combined into one data 
  density_list <- vector("list", length(call_id))
  
  for (i in seq_along(call_id)) {
    cid <- call_id[i]
    
    # Grab the capt & bincapt for this call ID
    sub_capt <- subset(capt, ID == cid)
    # Make sure to remove ID column when doing calculations
    sub_bin  <- subset(bincapt, ID == cid)[,-1] 
    ss.capt <- sub_capt$ss
    triggered_traps <- sub_capt$trap
    untriggered_traps <- setdiff(seq(n.traps), triggered_traps)
    
    # Initialize density matrix for this call
    mask.dens <- matrix(1, nrow = n.traps, ncol = nrow(mask))
    
    # Similar to how we calculate contribution from detection history alone
    for (j in seq_along(triggered_traps)) {
      mu.ss <- b0.ss - b1.ss*dists[triggered_traps[j], ]
      mask.dens[triggered_traps[j], ] <- dnorm(ss.capt[j], mu.ss, sigma.ss)
    }
    for (j in seq_along(untriggered_traps)) {
      mu.ss <- b0.ss - b1.ss*dists[untriggered_traps[j], ]
      mask.dens[untriggered_traps[j], ] <- pnorm(cutoff, mu.ss, sigma.ss)
    }
    
    mask.dens <- apply(mask.dens, 2, prod)
    
    density_list[[i]] <- data.frame(
      ID = cid, x = mask[, 1], y = mask[, 2], z = mask.dens
    )
  }
  
  return(do.call(rbind, density_list))
}

#' Calculate the capture history density
#' 
#' Calculates the capture history density of calls from a model fit using 
#' \link{fit.acre}.
#'
#' @inheritParams location_density
#'
#' @return a data frame with columns \code{x}, \code{y} and \code{capt_dens}
#' @export
#'
#' @examples
capt_density <- function(fit, call_id, animal_id=NULL, session=1, 
                       mask=get_mask(fit)[[session]], newdata=NULL) {
  # Note input validation for call_id, animal_id, session
  # is handled in `get_capt_by_id()`
  
  # Grab appropriate capture data
  capt <- get_capt_by_id(fit, call_id, animal_id, session)
  bincapt <- get_capt_by_id(fit, call_id, animal_id, session, return_bincapt=T)
  
  # Grab our estimated parameters, along with other model fitting parameters
  det_pars <- as.list(coef(fit, type="fitted"))
  if (fit$fit.types["ss"]) {
    det_pars$cutoff <- get_ss.opts(fit)$cutoff
  }
  detfn <- get_detfn(fit)
  ss.link <- get_ss_link(fit)
  traps <- get_trap(fit)[[session]]
  dists <- distances(traps, as.matrix(mask))
  
  # Only allow newdata argument for parameter extended models
  par_extended <- !is.null(get_par_extend(fit))
  if (!is.null(newdata) && !par_extended) {
    stop("'newdata' argument is only available for parameter extended models")
  }
  
  # Deal with extended parameters
  if (par_extended) {
    ext_par_matrices <- get_par_extend_matrix(fit, mask, traps, newdata = newdata)
    det_pars[names(ext_par_matrices)] <- ext_par_matrices
  }
  
  # A list to store each call density, will be combined into one data 
  density_list <- vector("list", length(call_id))
  
  for (i in seq_along(call_id)) {
    cid <- call_id[i]
    
    # Grab the capt & bincapt for this call ID
    sub_capt <- subset(capt, ID == cid)
    # Make sure to remove ID column when doing calculations
    sub_bin  <- as.numeric(subset(bincapt, ID == cid)[,-1]) 
    
    # Probability of detection at each mask point
    det.probs <- det_prob(detfn, det_pars, dists, ss.link)
    
    # Note that det_prob() returns E[SS] for ss models
    if(detfn == 'ss'){
      det.probs = 1 - pnorm(det_pars$cutoff, mean = det.probs, 
                            sd = det_pars$sigma.ss)
    }
    
    # Density due to capture history alone
    capt_dens <- apply((det.probs ^ sub_bin) * 
                         ((1 - det.probs) ^ (1 - sub_bin)), 2, prod)
    
    density_list[[i]] <- data.frame(
      ID = cid, x = mask[, 1], y = mask[, 2], z = capt_dens
    )
  }
  
  return(do.call(rbind, density_list))
}

#' Calculate the detection surface density
#' 
#' Calculates the detection surface density for a model fit using 
#' \link{fit.acre}.
#' 
#' See: https://research-repository.st-andrews.ac.uk/bitstream/handle/10023/18233/BenStevensonPhDThesis.pdf
#' (Equation 1.4)
#'
#' @inheritParams location_density
#' @return a data frame with columns \code{x}, \code{y} and \code{Dsurface_density}
#' @export
#'
#' @examples
Dsurface_density <- function(fit, session=1, mask=get_mask(fit)[[session]], 
                             newdata=NULL) {
  # Grab estimated parameters, along with other model fitting variables
  det_pars <- as.list(coef(fit, type="fitted"))
  detfn <- get_detfn(fit)
  if (fit$fit.types["ss"]) {
    det_pars$cutoff <- get_ss.opts(fit)$cutoff
  }
  ss_link <- get_ss_link(fit)
  traps <- get_trap(fit)[[session]]
  a <- attr(mask, "area")
  
  # Only allow newdata argument for parameter extended models
  par_extended <- !is.null(get_par_extend(fit))
  if (!is.null(newdata) && !par_extended) {
    stop("'newdata' argument is only available for parameter extended models")
  }
  
  # Deal with extended parameters
  if (par_extended) {
    ext_par_matrices <- get_par_extend_matrix(fit, mask, traps, newdata = newdata)
    det_pars[names(ext_par_matrices)] <- ext_par_matrices
  }
  
  # Calculating detection probabilities
  prob_det_total <- p.dot.defaultD(as.matrix(mask), traps, detfn, ss_link, 
                                det_pars, a)
  prob_det <- p.dot.defaultD(as.matrix(mask), traps, detfn, ss_link, det_pars, a, 
                          esa = F)
  
  # Calculating location density
  if (fit$fit.ihd){
    if (is.null(newdata)) {
      # Note that intensity mask is simply our estimated density at each mask
      # point
      intensity_mask <- fit$D.mask[[session]]
    } else {
      # Density cannot be trap-level extended, so take the first row as all the 
      # rows will be identical
      intensity_mask <- det_pars$D[1, ]
    }
    z <- (prob_det * intensity_mask) / (a * sum(prob_det * intensity_mask))
  } else {
    # Note that prob_det_total is already multiplied by `a` in p.dot.defaultD()
    z <- prob_det / prob_det_total
  }
  
  density.df <- data.frame(
    x = mask[, 1],
    y = mask[, 2],
    z = z
  )
  
  return(density.df)
}

plot_contour <- function(x, y, dens, n_levels) {
  unique.x <- sort(unique(x))
  unique.y <- sort(unique(y))
  z <- matrix(NA, nrow = length(unique.x), ncol = length(unique.y))
  for (i in 1:length(dens)){
    x_coord <- x[i]
    y_coord <- y[i]
    index.x <- which(x_coord == unique.x)
    index.y <- which(y_coord == unique.y)
    z[index.x, index.y] <- dens[i]
  }
  
  levels <- pretty(range(z, finite = TRUE), n_levels)
  
  contour(x = unique.x, y = unique.y, z = z, levels = levels, add = TRUE)
}

#' Create a plot subtitle for \link{plot_location_density}
#'
#' @inheritParams location_density
#'
#' @return a string to use as plot subtitle
#'
#' @examples
create_locations_plot_subtitle <- function(call_id, animal_id, session) {
  if (is.null(animal_id)) {
    subtitle = paste0("session: ", session, ", call ID: ", call_id)
  } else {
    if (length(call_id) == 1) {
      subtitle = paste0("session: ", session, ", animal ID: ", animal_id,
                     ", call ID: ", call_id)
    } else {
      subtitle = paste0("session: ", session, ", animal ID: ", animal_id)
    }
  }
  
  return(subtitle)
}

circle_fun <- function(center = c(0,0),diameter = 1, npoints = 35){
  r = diameter / 2
  tt <- seq(0,2*pi,length.out = npoints)
  xx <- center[1] + r * cos(tt)
  yy <- center[2] + r * sin(tt)
  return(data.frame(x = xx, y = yy))
}





