% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/functions_in_fit.R
\name{make_buffer_printer}
\alias{make_buffer_printer}
\title{Buffered trace printer for TMB objectives (paired fn/grad)}
\usage{
make_buffer_printer(
  trace_cols,
  only_improvements = TRUE,
  step = c("euclid", "max", "none"),
  show_mgc = TRUE,
  mgc_tol = 1e-10
)
}
\arguments{
\item{trace_cols}{Character vector of parameter names to print as columns
(typically \code{names(obj$par)} or a subset).}

\item{only_improvements}{Logical; if \code{TRUE} (default) print only when \code{fval}
strictly improves over the best so far (an “outer-like” trace). Set \code{FALSE}
to print every paired evaluation.}

\item{step}{One of \code{"euclid"}, \code{"max"}, \code{"none"}. Controls the optional
step-size column between successive \emph{printed} parameter vectors.}

\item{show_mgc}{Logical; if \code{TRUE}, include a \code{mgc} column equal to
\code{max(abs(grad))} at the matched point. Set \code{FALSE} if you do not have a
gradient (e.g. \code{gr.skip = TRUE}).}

\item{mgc_tol}{Numeric tolerance used to decide whether \code{fn} and \code{gr}
parameter vectors “match” (default \code{1e-10}).}
}
\value{
A list with callbacks:
\itemize{
\item \code{on_fn(par_vec, fval, par_names, G_matrix_list)}:
record an objective evaluation.
\item \code{on_gr(par_vec, grad_vec, par_names, G_matrix_list)}:
record a gradient evaluation.
}
Each callback returns \code{invisible(NULL)}; printing happens as a side effect.
}
\description{
Returns a small tap object with callbacks that you attach to the objective
and gradient produced by \code{\link[TMB:MakeADFun]{TMB::MakeADFun()}}. While optimizing (e.g. via
\code{\link[stats:nlminb]{stats::nlminb()}}), it prints a right-aligned, fixed-width row \strong{only when}
the objective value and gradient were both evaluated at the \strong{same}
parameter vector. This guarantees the \code{mgc} column (maximum absolute gradient
component) corresponds to the printed \code{fval}.
}
\details{
Because optimizers often evaluate the objective and gradient at different
points and in different orders (e.g. line search), the tap uses an internal
buffer to: (a) remember the most recent \code{fn} and \code{gr} evaluations, and
(b) print a row only when those evaluations match in parameters (within
\code{mgc_tol}).

Columns are \code{iter} (count of printed rows), \code{fval}, optional \code{mgc}, optional
\code{step} (Euclidean or max coordinate change since the previous \emph{printed} row),
followed by the parameter columns in \code{trace_cols}.
}
\section{Usage}{

\preformatted{
tap <- make_buffer_printer(trace_cols = names(obj$par),
                           step = "euclid",
                           show_mgc = TRUE)
obj$fn <- with_fn_tap(obj$fn, tap, par_names = names(obj$par))
obj$gr <- with_gr_tap(obj$gr, tap, par_names = names(obj$par))

opt <- stats::nlminb(obj$par, obj$fn, obj$gr, 
                               control = list(trace = 0))
}
}

\seealso{
\code{\link[TMB:MakeADFun]{TMB::MakeADFun()}}, \code{\link[stats:nlminb]{stats::nlminb()}}
}
