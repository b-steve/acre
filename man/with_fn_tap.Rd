% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/functions_in_fit.R
\name{with_fn_tap}
\alias{with_fn_tap}
\title{Wrap an objective to emit buffered trace rows on each evaluation}
\usage{
with_fn_tap(fn, tap, par_names, G_matrix_list)
}
\arguments{
\item{fn}{Objective function with signature \verb{function(par, ...) -> scalar}.}

\item{tap}{Tap/list returned by \code{\link[=make_buffer_printer]{make_buffer_printer()}}, expected to provide
a method \code{on_fn_evaluation(par_vec, fval, par_names)}.}

\item{par_names}{Character vector of names corresponding to \code{par}. These are
used by the tap to map positions in \code{par} onto the \code{trace_cols} it prints.}

\item{G_matrix_list}{List of back-transformation matrices used to back
transform parameter values in the case they have been scaled and centered
for model fitting.}
}
\value{
A function with the same signature and return value as \code{fn}, which
also triggers the tap side-effect after each evaluation.
}
\description{
Creates an idempotent wrapper around an objective function \code{fn(par, ...)}
that forwards the call unchanged, then notifies a tap object produced by
\code{\link[=make_buffer_printer]{make_buffer_printer()}} via \code{tap$on_fn_evaluation(par_vec, fval, par_names)}.
Use this with \code{\link[stats:nlminb]{stats::nlminb()}} (or similar optimizers) to stream live,
correctly paired trace rows when combined with \code{\link[=with_gr_tap]{with_gr_tap()}}.
}
\details{
The wrapper is \strong{idempotent}: if it detects the function was already wrapped
(attribute \code{.__fn_tapped}), it returns \code{fn} unchanged. Arguments are
\code{force()}d so the wrapper closes over the current objects.
}
\seealso{
\code{\link[=with_gr_tap]{with_gr_tap()}}, \code{\link[=make_buffer_printer]{make_buffer_printer()}}, \code{\link[stats:nlminb]{stats::nlminb()}}
}
